/*
Farcaster API V2

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapiv2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// FeedAPIService FeedAPI service
type FeedAPIService service

type ApiFeedRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	feedType *FeedType
	filterType *FilterType
	fid *int32
	fids *string
	parentUrl *string
	embedUrl *string
	withRecasts *bool
	limit *int32
	cursor *string
}

// API key required for authentication.
func (r ApiFeedRequest) ApiKey(apiKey string) ApiFeedRequest {
	r.apiKey = &apiKey
	return r
}

// Defaults to following (requires fid or address). If set to filter (requires filter_type)
func (r ApiFeedRequest) FeedType(feedType FeedType) ApiFeedRequest {
	r.feedType = &feedType
	return r
}

// Used when feed_type&#x3D;filter. Can be set to fids (requires fids) or parent_url (requires parent_url)
func (r ApiFeedRequest) FilterType(filterType FilterType) ApiFeedRequest {
	r.filterType = &filterType
	return r
}

// (Optional) fid of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type
func (r ApiFeedRequest) Fid(fid int32) ApiFeedRequest {
	r.fid = &fid
	return r
}

// Used when filter_type&#x3D;fids . Create a feed based on a list of fids. Max array size is 250. Requires feed_type and filter_type.
func (r ApiFeedRequest) Fids(fids string) ApiFeedRequest {
	r.fids = &fids
	return r
}

// Used when filter_type&#x3D;parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type
func (r ApiFeedRequest) ParentUrl(parentUrl string) ApiFeedRequest {
	r.parentUrl = &parentUrl
	return r
}

// Used when filter_type&#x3D;embed_url can be used to fetch all casts with an embed url that contains embed_url. Requires feed_type and filter_type
func (r ApiFeedRequest) EmbedUrl(embedUrl string) ApiFeedRequest {
	r.embedUrl = &embedUrl
	return r
}

// Include recasts in the response, true by default
func (r ApiFeedRequest) WithRecasts(withRecasts bool) ApiFeedRequest {
	r.withRecasts = &withRecasts
	return r
}

// Number of results to retrieve (default 25, max 100)
func (r ApiFeedRequest) Limit(limit int32) ApiFeedRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFeedRequest) Cursor(cursor string) ApiFeedRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFeedRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedExecute(r)
}

/*
Feed Retrieve casts based on filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedRequest
*/
func (a *FeedAPIService) Feed(ctx context.Context) ApiFeedRequest {
	return ApiFeedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedExecute(r ApiFeedRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.Feed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.feedType == nil {
		return localVarReturnValue, nil, reportError("feedType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "feed_type", r.feedType, "")
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_type", r.filterType, "")
	}
	if r.fid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "")
	}
	if r.fids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fids", r.fids, "")
	}
	if r.parentUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_url", r.parentUrl, "")
	}
	if r.embedUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed_url", r.embedUrl, "")
	}
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
